use std::fs;
use std::path::Path;

use eyre::Report;

pub fn symlink(src: &Path, dest: &Path) -> Result<(), Report> {
    #[cfg(unix)]
    {
        if dest.exists() {
            fs::remove_file(&dest)?;
        }
        std::os::unix::fs::symlink(&src, &dest)?;
    }

    #[cfg(windows)]
    {
        use std::fs::File;
        use std::io::Write;

        // instead of create a symlink in windows
        // we should generate a bat/shell file like this
        let filename = (*dest)
            .to_path_buf()
            .file_name()
            .unwrap()
            .to_str()
            .unwrap()
            .to_owned();

        // generate a bat
        {
            let bat_file_name = filename.clone() + ".bat";

            let bat_file_path = dest.parent().unwrap().join(bat_file_name);

            let mut bat_file = File::create(bat_file_path)?;

            bat_file.write_all(
                format!(
                    r#":: The file is generated by Cask. DO NOT MODIFY IT.
@ECHO OFF

SETLOCAL

"{}" %*
"#,
                    src.as_os_str().to_str().unwrap()
                )
                .as_str()
                .as_bytes(),
            )?;
        }

        // generate a shell
        {
            let bat_file_name = &filename;

            let bat_file_path = dest.parent().unwrap().join(bat_file_name);

            let mut bat_file = File::create(bat_file_path)?;

            bat_file.write_all(
                format!(
                    r#"#!/bin/sh
# The file is generated by Cask. DO NOT MODIFY IT.

(set -o igncr) 2>/dev/null && set -o igncr; # cygwin encoding fix

"{}" "$@"
"#,
                    src.as_os_str().to_str().unwrap()
                )
                .as_str()
                .as_bytes(),
            )?;
        }
    }

    Ok(())
}
